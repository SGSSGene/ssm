#include "universe.h"

#include <iostream>
#include <fstream>
#include <unistd.h>

#include "testing.h"

std::string trim(std::string line) {
	while(line.size() > 0 && std::isspace(line[line.size()-1])) {
		line.erase(line.size()-1);
	}

	while(line.size() > 0 && std::isspace(*line.begin())) {
		line.erase(line.begin());
	}
	return line;
}
bool isValidName(std::string const _name) {
	if (_name.size() <= 0) return false;
	if (_name.at(0) != '_' && !std::isalpha(_name.at(0))) {
		return false;
	}

	for (auto c : _name) {
		if (c != '_' && !std::isalnum(c) && c != '.') {
			return false;
		}
	}
	return true;
}


using namespace SimpleStateMachine;

void dotGenerator(std::istream& _ifile, std::ostream& _ofile) {
	Universe uni(_ifile, _ofile);
	std::cout<<uni.getErrorMessages();
}
void c__11Generator(std::istream& _ifile, std::ostream& _ofile, std::string _machineName, std::string _path) {
	Universe uni;
	UniverseImage image = uni.parse(_ifile);


	_ofile << "#ifndef SIMPLESTATEMACHINE_"<<_machineName<<"_AUTOGENERATED"<<std::endl;
	_ofile << "#define SIMPLESTATEMACHINE_"<<_machineName<<"_AUTOGENERATED"<<std::endl;
	_ofile << "// this is auto generated\n\n";
	_ofile << "#include \""<<_path<<"/universe.h\"\n";
	_ofile << "#include \""<<_path<<"/universeImage.h\"\n\n";

	_ofile << "static SimpleStateMachine::UniverseImage "<<_machineName<<" = {"<<std::endl;
	_ofile << "// Machine Map\n";

	for (auto iterM = image.begin(); iterM != image.end(); ++iterM) {
		_ofile << "\t// Machine Entry\n";
		_ofile << "\t{ std::string(\"" << iterM->first <<"\"), { std::string(\"" << iterM->second.initialState << "\"), {\n";
		_ofile << "\t// State Map\n";
		for (auto iterS = iterM->second.stateImageMap.begin(); iterS != iterM->second.stateImageMap.end(); ++iterS) {
			_ofile <<"\t\t// State Entry\n";
//!TODO doesn't work with fucntionimage (state)
//			_ofile <<"\t\t{ std::string(\""<< iterS->first <<"\"), { std::string(\""<<iterS->second.action<<"\"), "<<(iterS->second.force?"true":"false")<<", {"<<std::endl;
			_ofile <<"\t\t// Transition List\n";
			for (auto iterT = iterS->second.transitionSet.begin(); iterT != iterS->second.transitionSet.end(); ++iterT) {
				_ofile <<"\t\t\t// Transition Entry\n";
//!TODO doesn't work with parameters yet (condition)
/*				_ofile <<"\t\t\t { std::string(\""<<iterT->condition<<"\"), ";
				_ofile <<"std::string(\""<<iterT->targetState<<"\"), ";
				std::string testType = "None";
				if (iterT->testType == SimpleStateMachine::TransitionImage::TestType::Equal) {
					testType = "Equal";
				} else if (iterT->testType == SimpleStateMachine::TransitionImage::TestType::Unequal) {
					testType = "Unequal";
				}

				_ofile <<"SimpleStateMachine::TransitionImage::TestType::"<<testType<<", ";
				_ofile <<"std::string(\""<<iterT->testAgainstString<<"\")}";

				if (std::next(iterT) != iterS->second.transitionSet.end()) {
					_ofile << ",";
				}
				_ofile << std::endl;*/

			}
			_ofile <<"\t\t}, {\n";
			_ofile <<"\t\t// SubMachine List\n";
			for (auto iterSub = iterS->second.machineNameSet.begin(); iterSub != iterS->second.machineNameSet.end(); ++iterSub) {
				_ofile <<"\t\t\t//SubMachine Entry\n";
				_ofile <<"\t\t\t{ std::string(\""<<*iterSub<<"\") }";
				if (std::next(iterSub) != iterS->second.machineNameSet.end()) {
					_ofile << ",";
				}
				_ofile << std::endl;
			}

			_ofile <<"\t\t}}}";
			if (std::next(iterS) != iterM->second.stateImageMap.end()) {
				_ofile << ",";
			}
			_ofile << std::endl;
		}

		_ofile << "\t}}}";
		if (std::next(iterM) != image.end()) {
			_ofile << ",";
		}
		_ofile << std::endl;
	}
	_ofile <<"};\n\n";

	_ofile << "#endif // SIMPLESTATEMACHINE_"<<_machineName<<"_AUTOGENERATED"<<std::endl;
}

void startInteractiveMode(std::istream& _ifile) {
	// Get Requirements
	std::map<std::string, bool> conditionState;
	std::map<std::string, std::string> conditionStringState;

	ActionMap actionMap;
	ConditionMap conditionMap;
	{
		Universe uni(_ifile);
		std::cout<<uni.getErrorMessages();
		for (auto a : uni.getRequiredActions()) {
			actionMap[a.first] = [a]() {
				std::cout << "Action: "<< a.first << std::endl;
			};
		}
		actionMap["__void__"] = []() {
			std::cout << "Action: none"<<std::endl;
		};
		for (auto c : uni.getRequiredConditions()) {
			conditionState[c.first] = false;
			conditionMap[c.first] = [&conditionState, c]() {
				return conditionState.at(c.first);
			};
		}
	}
	{
		//Universe uni(_ifile, conditionMap, conditionStringMap, actionMap);
		Universe uni;

		auto machine = uni.bootstrap(_ifile);
		std::cout<<uni.getErrorMessages();

		while(true) {
			machine->executeStep();
			if (std::cin.peek() > 0) {
				std::string conditionName;
				bool newValue;
				std::string in;
				std::getline(std::cin, in);
				if (in == "") continue;
				bool valid(true);
				if (in.find('=') == std::string::npos) {
					valid = false;
				} else {
					std::string var1 = in;
					std::string var2 = in;
					var1.erase(var1.begin()+var1.find('='), var1.end());
					var2.erase(var2.begin(), var2.begin()+var2.find('=')+1);
					var1 = trim(var1);
					var2 = trim(var2);
					if (var2 != "true" && var2 != "false") {
						valid = false;
					} else if (!isValidName(var1)) {
						valid = false;
					} else {
						conditionName = var1;
						newValue = (var2 == "true")?true:false;
						conditionState[conditionName] = newValue;
					}

				}
				if (valid) {
					std::cout<<"Condition: "<<conditionName<<" = "<<(newValue?"true":"false")<<std::endl;
				} else {
					std::cerr<<"Error: "<<"Ilformed input"<<std::endl;
				}
			}
			sleep(1);
		}
	}
}
void generateListOfRequirements(std::istream& _ifile) {
	Universe uni(_ifile);
	std::cout<<uni.getErrorMessages();

	std::cout<<"Required Actions: ("<<uni.getRequiredActions().size()<<")"<<std::endl;
	for (auto a : uni.getRequiredActions()) {
		std::cout<<"\tstd::function<"<<a.second<<"> "<<a.first<<std::endl;
	}

	std::cout<<"\nRequired Conditions: ("<<uni.getRequiredConditions().size()<<")"<<std::endl;
	for (auto c : uni.getRequiredConditions()) {
		std::cout<<"\tstd::function<"<<c.second<<"> "<<c.first<<std::endl;
	}
}
int main(int argc, char** args) {

	if (argc >= 2) {
		std::string option = args[1];
		if (option == "--dot") {
			//std::ifstream istream("test.sm");
			//std::ofstream ostream("sm.dot");
			//dotGenerator(istream, ostream);

			dotGenerator(std::cin, std::cout);
		} else if (option == "--interactive") {
			startInteractiveMode(std::cin);
		} else if (option == "--requirements") {
			generateListOfRequirements(std::cin);
		} else if (option =="--c++11" && argc >= 4) {
			std::string machineName = args[2];
			std::string path        = args[3];
			std::stringstream ss;
			ss<<machineName<<".h";
			std::ofstream fout(ss.str());
			c__11Generator(std::cin, fout, machineName, path);
		} else if (option =="--testing") {
			testing();
		}

	}
	return 0;
}


