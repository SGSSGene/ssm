#include "universe.h"

#include <iostream>
#include <fstream>
#include <unistd.h>

std::string trim(std::string line) {
	while(line.size() > 0 && std::isspace(line[line.size()-1])) {
		line.erase(line.size()-1);
	}

	while(line.size() > 0 && std::isspace(*line.begin())) {
		line.erase(line.begin());
	}
	return line;
}
bool isValidName(std::string const _name) {
	if (_name.size() <= 0) return false;
	if (_name.at(0) != '_' && !std::isalpha(_name.at(0))) {
		return false;
	}

	for (auto c : _name) {
		if (c != '_' && !std::isalnum(c) && c != '.') {
			return false;
		}
	}
	return true;
}


using namespace SimpleStateMachine;

void dotGenerator(std::istream& _ifile, std::ostream& _ofile) {
	Universe uni(_ifile, _ofile);
	std::cout<<uni.getErrorMessages();
}
void c__11Generator(std::istream& _ifile, std::ostream& _ofile, std::string _machineName) {
	Universe uni;
	UniverseImage image = uni.parse(_ifile);
	std::cerr<<uni.getErrorMessages();
	auto _MachineName = _machineName;
	_MachineName.at(0) = std::toupper(_MachineName.at(0));

	_ofile << "#ifndef SIMPLESTATEMACHINE_"<<_MachineName<<"_AUTOGENERATED"<<std::endl;
	_ofile << "#define SIMPLESTATEMACHINE_"<<_MachineName<<"_AUTOGENERATED"<<std::endl;
	_ofile << "// this is auto generated\n\n";
	_ofile << "#include <ssm/simpleStateMachine.h>\n";

	_ofile << "class "<<_MachineName<<" {\n";
	_ofile << "private:\n";
	_ofile << "\tSimpleStateMachine::Universe universe;\n";
	_ofile << "\tstd::shared_ptr<SimpleStateMachine::Machine> machine;\n\n\n";
	_ofile << "public:\n";
	_ofile << "\ttemplate<typename T>\n";
	_ofile << "\t"<<_MachineName<<"(T t) {\n";
	_ofile << "\t\tSimpleStateMachine::autoRegisterAll(&universe, t);\n";
	_ofile << "\t\tmachine = universe.bootstrap(getImage());\n";
	_ofile << "\t}\n";
	_ofile << "\tbool runOneStep(bool b) {\n";
	_ofile << "\t\treturn machine->executeStep();\n";
	_ofile << "\t}\n";
	_ofile << "\tvoid run() {\n";
	_ofile << "\t\twhile(machine->executeStep());\n";
	_ofile << "\t}\n";

	_ofile << "private:\n";
	_ofile << "\tSimpleStateMachine::UniverseImage getImage() {\n";
	_ofile << "\t\tstatic SimpleStateMachine::UniverseImage image_"<<_machineName<<" = {"<<std::endl;
	_ofile << "\t// Machine Map\n";

	for (auto iterM = image.begin(); iterM != image.end(); ++iterM) {
		_ofile << "\t\t// Machine Entry\n";
		_ofile << "\t\t{ std::string(\"" << iterM->first <<"\"),\n";
		iterM->second.stream(_ofile, "\t\t\t");
		_ofile << "\n\t\t},\n";
	}
	_ofile <<"\t\t};\n";
	_ofile <<"\t\treturn image_"<<_machineName<<";\n";
	_ofile <<"\t}\n";

	_ofile <<"};\n\n";

	std::map<std::string, std::pair<std::string, std::string>> actionCalls;
	std::map<std::string, std::pair<std::string, std::string>> conditionCalls;
	auto ignoreActions    = uni.getIgnoreActions();
	auto ignoreConditions = uni.getIgnoreConditions();

	for (auto m : image) {
		for (auto s : m.second.stateImageMap) {
			ignoreConditions.insert(m.first+"."+s.first);
			auto f = s.second.function;
			actionCalls[f.genericFunction] = std::make_pair(f.extendedFunction, f.broadSignature);
			for (auto t : s.second.transitionSet) {
				auto f = t.functionImage;
				conditionCalls[f.genericFunction] = std::make_pair(f.extendedFunction, f.broadSignature);
			}
		}
	}

	for (auto x : ignoreActions) {
		actionCalls.erase(x);
	}
	for (auto x : ignoreConditions) {
		conditionCalls.erase(x);
	}

	for (auto a : actionCalls) {
		_ofile<<"DEF_GET_METHOD_CALL("<<a.first<<", "<<a.second.first<<", "<<a.second.second<<")"<<std::endl;
	}
	for (auto a : conditionCalls) {
		_ofile<<"DEF_GET_METHOD_CALL("<<a.first<<", "<<a.second.first<<", "<<a.second.second<<")"<<std::endl;
	}


	_ofile << "\nDEF_AUTO_REGISTER_BEGIN" << std::endl;
	for (auto a : actionCalls) {
		_ofile<<"\tDEF_AUTO_REGISTER_ACTION("<<a.first<<")\n";
	}
	for (auto a : conditionCalls) {
		_ofile<<"\tDEF_AUTO_REGISTER_CONDITION("<<a.first<<")\n";
	}
	_ofile << "DEF_AUTO_REGISTER_END" << std::endl;

	_ofile << "#endif // SIMPLESTATEMACHINE_"<<_machineName<<"_AUTOGENERATED"<<std::endl;
}

void generateListOfRequirements(std::istream& _ifile) {
	Universe uni(_ifile);
	std::cout<<uni.getErrorMessages();

	std::cout<<"Required Actions: ("<<uni.getRequiredActions().size()<<")"<<std::endl;
	for (auto a : uni.getRequiredActions()) {
		std::cout<<"\tstd::function<"<<a.second<<"> "<<a.first<<std::endl;
	}

	std::cout<<"\nRequired Conditions: ("<<uni.getRequiredConditions().size()<<")"<<std::endl;
	for (auto c : uni.getRequiredConditions()) {
		std::cout<<"\tstd::function<"<<c.second<<"> "<<c.first<<std::endl;
	}
}

int main(int argc, char** args) {

	if (argc >= 2) {
		std::string option = args[1];
		if (option == "--dot") {
			std::string machineName = args[2];
			std::stringstream ssi;

			if (machineName.size() >= 3
				&& machineName.substr(machineName.size()-3, 3) == ".sm") {
				machineName = machineName.substr(0, machineName.size()-3);
			}

			ssi<<machineName<<".sm";
			std::ifstream fin(ssi.str());

			if (!fin.is_open()) {
				std::cerr<<"Couldn\'t open file"<<std::endl;
				return 1;
			}
			dotGenerator(fin, std::cout);

			return 0;
		} else if (option == "--requirements" && argc >= 3) {
			std::string machineName = args[2];
			std::stringstream ssi;
			if (machineName.size() >= 3
				&& machineName.substr(machineName.size()-3, 3) == ".sm") {
				machineName = machineName.substr(0, machineName.size()-3);
			}
			ssi<<machineName<<".sm";

			std::ifstream fin(ssi.str());

			if (!fin.is_open()) {
				std::cerr<<"Couldn\'t open file"<<std::endl;
				return 1;
			}
			generateListOfRequirements(fin);
			return 0;
		} else if (option =="--c++11" && argc >= 3) {
			std::string machineName = args[2];

			if (machineName.size() >= 3
				&& machineName.substr(machineName.size()-3, 3) == ".sm") {
				machineName = machineName.substr(0, machineName.size()-3);
			}

			std::stringstream sso, ssi;
			sso<<machineName<<".sm.h";
			ssi<<machineName<<".sm";
			std::ofstream fout(sso.str());
			std::ifstream fin(ssi.str());

			if (!fin.is_open()) {
				std::cerr<<"Couldn\'t open file"<<std::endl;
				return 1;
			}
			if (!fout.is_open()) {
				std::cerr<<"Couldn\'t open file"<<std::endl;
				return 1;
			}


			c__11Generator(fin, fout, machineName);
			return 0;
		}
	}
	std::cout<<"Usage: ssm [OPTION]"<<std::endl;
	std::cout<<""<<std::endl;
	std::cout<<"OPTIONs:"<<std::endl;
	std::cout<<"--dot\t\t"<<"generate a file that can be compiled with dot"<<std::endl;
	std::cout<<"--requirements\t"<<"print a list of all actions and condition needed by the given ssm"<<std::endl;
	std::cout<<"--c++11\t\t"<<"generate heavy wizardry file, to be included"<<std::endl;
	return 0;
}


